# 牛客网刷题笔记
## 序言和计划
* 总题量：200
* 分布：

    | 难易度 | 数量 |
    |------|----|
    | 入门  | 2  |
    | 简单  | 25 |
    | 中等  | 41 |
    | 困难  | 32 |
    | 极难  | 8  |

    **刷题计划：**
  * Phase1（入门+简单+中等）: 每日七题，*吃透，挖透，弄明白原理*
  * Phase2（困难+极难）: 每日五题，*弄懂算法类别，抄透，抄熟*

-------
## DAY 1 ##
### Q1: 进制转换 ###
题目描述

```
输入一个int型的正整数，计算出该int型数据在内存中存储时1的个数。
```

输入描述:
```
输入一个整数（int类型）
```
输出描述:
```
这个数转换成2进制后，输出1的个数
```
我的答案：
```python
num = int(input())
bi_num = bin(num)
print(bi_num.count('1'))
```
别人的答案：
```python
while True
    try:
        print(bin(int(input)).count('1'))
    except:
        break
```
**关键点：**
1、bin（）十进制转二进制转换函数，同理有oct(), hex(), str()等类型转换函数
*都是十进制转X进制，如果实现任意进制转换套娃即可，如下表:*

|      | 二进制        | 八进制           | 十进制            | 十六进制           |
|------|---------------|---------------|----------------|----------------|
| 二进制  | \             | bin(int(x,8)) | bin(int(x,10)) | bin(int(x,16)) |
| 八进制  | oct(int(x,2)) | \             | oct(int(x,10)) | oct(int(x,16)) |
| 十进制  | str(int(x,2)) | str(int(x,8)) | \              | str(int(x,16)) |
| 十六进制 | hex(int(x,2)) | hex(int(x,8)) | hex(int(x,10)) | \              |

2、转换后利用`count()`函数进行对某个字符串/数字的计数功能

**我的不足:**

没有使用`try`，`break`等函数来确保输入数字的类型错误不会发生

**PS**
    另外，如果不使用内置函数进行进制转换，还可以根据取余数的算法
    `quotinent, remiander = divmod(dividend, divisor)`
    来手动做~~好像有点画蛇添足~~
    (详见：[用Python实现进制转换，这一篇教程就够了](https://juejin.im/post/6844903930200064014))

----

### Q2:取近似数 ###

题目描述：
```
写出一个程序，接受一个正浮点数值，输出该数值的近似整数值。如果小数点后数值大于等于5,向上取整；小于5，则向下取整。
```
输入：
```
输入一个正浮点数值
```
输出：
```
输出该数值的近似整数
```
我的答案：
```python
from math import floor
print(int(floor(float(input()) + 0.5 )))
```
比较容易犯的错误：
```
print(round( float( input() ) ))
```
*这个地方的错误点在于，对于python3的内置*‘round()’*函数，其功能并非我们熟知的四舍五入，在一个整数恰好被均分的时候，python会返回其最接近的偶数，而并非向上取整*
([python3官方文档对于round函数的解释](https://docs.python.org/3/library/functions.html#round))
例子：
```python
number1 = 4.5
print(round(number1)) --> 4
number2 = 5.5
print(round(number2)) --> 6
```
此外，除了round函数本身的问题外，python的浮点数（或者说**计算机存储浮点数的方式**）都会导致误差的出现，在进行精确计算时应该使用`Decimal()`函数进行类型限制

----

### Q3：数字颠倒（简单
题目描述：
```
输入一个整数，将这个整数以字符串的形式逆序输出
程序不考虑负数的情况，若数字含有0，则逆序形式也含有0，如输入为100，则输出为001
```
输入：
```
输入一个int整数
```
输出：
```
将这个整数以字符串的形式逆序输出
```
我的答案：
```python
print(str(input())[::-1])
```
另外的答案：
```python
s = str(input())
print(''.join(reversed(s)))
```
## 关键点：
1、python内置的列表倒置操作[::-1]
2、python内置字符串操作`.join(reversed())`

## Q4：字符串倒置
题目描述：
```
写出一个程序，接受一个字符串，然后输出该字符串反转后的字符串。（字符串长度不超过1000）
```
输入：
```
输入N个字符
```
输出：
```
输出该字符串反转后的字符串
```
## 和上一题同理，略过

----
### Q5: 汽水瓶（简单）
题目描述：
```
有这样一道智力题：“某商店规定：三个空汽水瓶可以换一瓶汽水。小张手上有十个空汽水瓶，她最多可以换多少瓶汽水喝？”答案是5瓶，方法如下：先用9个空瓶子换3瓶汽水，喝掉3瓶满的，喝完以后4个空瓶子，用3个再换一瓶，喝掉这瓶满的，这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板。如果小张手上有n个空汽水瓶，最多可以换多少瓶汽水喝
```
输入：
```
输入文件最多包含10组测试数据，每个数据占一行，仅包含一个正整数n（1<=n<=100），表示小张手上的空汽水瓶数。n=0表示输入结束，你的程序不应当处理这一行。
```
输出：
```
对于每组测试数据，输出一行，表示最多可以喝的汽水瓶数。如果一瓶也喝不到，输出0。
```
例子：
输入

```
3
10
81
0
```
输出

```
1
5
40
```
我的答案：
```python
while True:
    try: 
        n = int(input())
        if n == 0:
            break
        exchanged = 0
        while n > 2:
            exchanged = exchanged + n//3
            n = n%3 + n//3
        if n == 2:
            exchanged += 1
        print(exchanged)
    except:
        break
```
思路：问题的直接解法是一个递归的除法，每次余数和商相加得到新的被除数，累加每次得到的新的商就是，如果最后商为2，则总数+1，其他则不加
别人的解法：
```python
while True:
    try:
        a=int(input())
        if a !=  0:
            print(a//2)   
    except:
        break
```
思路：解法非常的巧妙，最后一句描述 __这时候剩2个空瓶子。然后你让老板先借给你一瓶汽水，喝掉这瓶满的，喝完以后用3个空瓶子换一瓶满的还给老板__ 暗示，其实本质上每两个瓶子就可以换一个，所以直接`n//2`就可以了

-----

### Q6: 统计每个月兔子数量

  问题描述

```
  有一只兔子，从出生后第3个月起每个月都生一只兔子，小兔子长到第三个月后每个月又生一只兔子，假如兔子都不死，问每个月的兔子总数为多少？
  本题有多组数据。
```

输入:

```
输入int型表示month
```

输出：

```
输出兔子总数int型
```

我的答案:

```python
def febonacci(n):
    if n <= 0:
        return 0
    elif n == 1:
        return 1
    else:
        return febonacci(n-1) + febonacci(n-2)
while True:
    try:
        month = int(input())
        print(febonacci(month))
    except:
        break
```
* 思路
  这是个典型的斐波那契数列问题，对于斐波那契数列，其递推公式为`f(n) = f(n-1) + f(n-2)`，因此，利用递推函数就可以快速写出
别人的答案

```pyhton
while True:
    try:
        month=int(input())
        a,b=1,0
        for i in range(month):
            a,b=b,a+b
        print(b)
    except:
        break
```
* 不同处:
同样是利用了递推的算法，但他的速度明显快于我的算法，其主要原因是我自己定义了一个函数来计算斐波那契数列的每一项，每次都要重新调用，从而浪费了大量的运算时间
### PS
有关斐波那契数列，还可以直接写出通项公式来计算

参考：[斐波那契数列四种python表示法](https://blog.csdn.net/FontThrone/article/details/78429771)

----

### Q7: 算术表达式
题述：
```
实现四则远算
```

输入:
```
算术表达式
```

输出:
```
计算结果
```
例子:
```
input:
3+2*{1+2*[-4/(8-6)+7]}

output:
25
```

我的答案:
```python
equation = input()
equation = equation.replace('[','(')
equation = equation.replace(']',')')
equation = equation.replace('{','(')
equation = equation.replace('}',')')
print(eval(equation))
```
python的思路比较简单,只需要将表达式的中括号和大括号进行替换即可

**关键点:**
 1. replace函数的使用
 2. eval()函数的使用

其他的答案:

`大同小异不再列出`

----

### Q4:杨辉三角的变形(简单)
题述:
```
1
1  1  1
1  2  3  2  1
1  3  6  7  6  3  1
1  4  10 16 19  16 10  4  1
以上三角形的数阵，第一行只有一个数1，以下每行的每个数，是恰好是它上面的数，左上角数到右上角的数，3个数之和（如果不存在某个数，认为该数就是0）。
求第n行第一个偶数出现的位置。如果没有偶数，则输出-1。例如输入3,则输出2，输入4则输出3。

输入n(n <= 1000000000)
本题有多组输入数据，输入到文件末尾，请使用while(cin>>)等方式读入
```

输入:
```
输入一个int整数
```
输出:
```
一个int值
```

我的代码：
```python
while True:
    try:
        n = int(input())
        if n == 1 or n ==2:
            print(-1)
        elif n%2 == 1:
            print(2)
        elif (n - 2)%4 == 0:
            print(4)
        else:
            print(3)
    except:
        break
```
实际上,这种方法比较投机取巧,通过观察10行三角数列的奇偶性来做出总结,发现在第二行之后,奇数行往往都是第二个数为偶数,而偶数行分为两种情况,分别作出`if`来进行输出

**缺点:**
这样的的方法显然不具有普适性,而且太过于投机取巧.接下来将进行比较传统的解法

testing for github push